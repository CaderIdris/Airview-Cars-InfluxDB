#!/bin/python3

""" Contains classes and methods that read raw measurements from AirView cars

This module contains classes and methods to read raw measurements from AirView
cars, convert the metadata to a human readable format and format the
measurements so they can be saved as a file or written to a database.

    Classes: 
        AirView: Handles reading raw measurements, converting metadata to human
        readable format and formatting the data
        
"""

__author__ = "Idris Hayward"
__copyright__ = "2021, Idris Hayward"
__credits__ = ["Idris Hayward"]
__license__ = "GNU General Public License v3.0"
__version__ = "1.0"
__maintainer__ = "Idris Hayward"
__email__ = "CaderIdrisGH@outlook.com"
__status__ = "Stable Release"

import pandas as pd
import datetime as dt
from collections import defaultdict as dd

class AirView:
    """ Handles raw measurements, converting metadata to human readable format
    and formatting the data

    Attributes:
        car (str): Serial number of the car

        measurements (list): List of containers, each representing measurements
        made at a point in time
        
        metadata (dict): Contains info on how to convert status codes in to
        human readable forms

        parameters (dataframe): Contains name and units of measured paramters,
        used to convert from parameter to id to human readable name

    Methods:
    __init__: Initialises class

    read_file: Reads a csv file generated by the AirView cars

    read_row: Reads a row from the csv file

    read_status: Reads a status string corresponding to a measurement

    get_measurements: Return a list of json measurements

    clear_measurements: Clear list of measurements

    """

    def __init__(self, car, metadata, parameters):
        """ Initialises class
        """
        self.car = car
        self.measurements = list()
        self.metadata = metadata
        self.parameters = parameters
        self.previous_date = dt.datetime(1970, 1, 1, 0, 0, 0)
        self.data_container = None

    def read_file(self, file_path):
        """ Reads a csv file generated by the AirView cars

        Reads a csv file generated by the AirView cars, translates the metadata
        in to a human readable form and formats it for upload to an InfluxDB
        2.x database

        Keyword arguments:
            file_path (str): path to file to be analysed

        Returns:
            None
        """
        # Open and format file
        file_data_raw = pd.read_csv(
                filepath_or_buffer=file_path,
                header=None,
                names=[
                    "Datetime",
                    "Device",
                    "Parameter ID",
                    "Status",
                    "Measurement",
                    "Measurement Number"
                    ],
                on_bad_lines='skip',
                )
        file_data = file_data_raw.drop_duplicates()
        updated_datetime = list(pd.to_datetime(
                file_data.loc[:,"Datetime"],
                format="%Y-%m-%d_%H-%M-%S.%f",
                ))
        file_data = file_data.assign(**{"Datetime":updated_datetime})

        # Read csv 
        for index, row in file_data.iterrows():
            if self.previous_date != row["Datetime"]:
                if self.data_container is not None:
                    self.measurements.append(self.data_container)
                self.data_container = {
                        "measurement": "AirView",
                        "time": row["Datetime"],
                        "fields": dict(),
                        "tags": {"Car": self.car}
                        }
                try:
                    self.read_row(row)
                except (KeyError, IndexError) as e:
                    pass
                self.previous_date = row["Datetime"]
            else:
                try:
                    self.read_row(row)
                except (KeyError, IndexError) as e:
                    pass
        self.measurements.append(self.data_container)

    def read_row(self, row):
        """ Reads a row from the csv file

        Reads the provided row from the csv file

        Keyword arguments:
            row (Pandas series): Row from the csv file

        Returns: 
            None
        """
        instrument_number = str(row["Device"]).split(":")[1]
        instrument_name = self.metadata["Devices"][instrument_number]
        measurement = str(self.parameters.iloc[int(row["Parameter ID"]) - 1, 1])
        units = str(self.parameters.iloc[int(row["Parameter ID"]) - 1, 2])
        measurement_name = f"{instrument_name} {measurement} {units}"
        self.data_container["fields"][measurement_name] = float(
                row["Measurement"]
                )
        if int(instrument_number) <= 7:
            self.read_status(str(row["Status"]), instrument_name, instrument_number)

    def read_status(self, raw_code, instrument, number):
        """ Reads a status string from the csv file and changes it to a human
        readable name

        The status strings are too complicated to discuss in detail here but 
        more info can be found in README.md and the metadata folder

        Keyword arguments:
            raw_code (str): The raw status code, either in the form of an 8
            nibble hex or 5 digit quinary

            instrument (str): What instrument the code corresponds to

            number (str): The instrument number

        Returns:
            None
        """
        status_string = ""
        separator = ""
        if len(number) <= 6 and len(raw_code) == 8:
            # The trigger bit corresponds to whatever bit corresponds to a
            # particular status code e.g if the 16th bit of instrument 1's
            # status code is 1, that means there is a sensor flow error.
            # The trigger bit is 0 for some instruments and 1 for others.
            status_data = self.metadata["Status"]["8 Nibble Hex"][number]
            trigger_bit = status_data["Trigger"]
            code = f"{int(raw_code, 16):0>32b}"[::-1]
            for bit, status in list(status_data.items()):
                if bit != 'Trigger':
                    if code[int(bit)] == trigger_bit:
                        status_string = f"{status_string}{separator}{status}"
                        separator = ", "
            if len(status_string) == 0:
                status_string = "5x5"
        elif int(number) == 7 and len(raw_code) == 5:
            status_data = self.metadata["Status"]["5 Digit Quinary"][number]
            for quit in list(status_data.keys()):
                status_string = f"{status_string}{separator}{status_data[quit][raw_code[int(quit)]]}"
                separator = ", "
        if len(status_string) == 0:
            status_string = "Unrecognised Status Code"
        self.data_container["tags"][f"{instrument} Status"] = status_string

    def get_measurements(self):
        """ Return list of measurements formatted for InfluxDB 2.x database

        Returns:
            List of dicts which contain all measurements at a point in time
            to be uploaded to an InfluxDB 2.x database
        """
        return self.measurements

    def clear_measurements(self):
        """ Clear all measurements from memory

        Returns:
            None
        """
        self.measurements = list()

